// $Id: IpAddress.java,v 1.30 2006/01/05 14:07:25 belaban Exp $

package org.jgroups.stack;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jgroups.Address;
import org.jgroups.Global;

import java.io.*;
import java.net.InetAddress;



/**
 * Network-dependent address (Internet). Generated by the bottommost layer of the protocol
 * stack (UDP). Contains an InetAddress and port.
 * @author Bela Ban
 */
public class IpAddress implements Address {
    private InetAddress             ip_addr=null;
    private int                     port=0;
    private byte[]                  additional_data=null;
    protected static final Log      log=LogFactory.getLog(IpAddress.class);
    static boolean                  resolve_dns=false;
    transient int                   size=-1;

    static {
        /* Trying to get value of resolve_dns. PropertyPermission not granted if
        * running in an untrusted environment  with JNLP */
        try {
            resolve_dns=Boolean.valueOf(System.getProperty("resolve.dns", "false")).booleanValue();
        }
        catch (SecurityException ex){
            resolve_dns=false;
        }
    }



    // Used only by Externalization
    public IpAddress() {
    }
    
    public IpAddress(String i, int p) {
        port=p;
    	try {
        	ip_addr=InetAddress.getByName(i);
        }
        catch(Exception e) {
            if(log.isWarnEnabled()) log.warn("failed to get " + i + ": " + e);
        }
        if(this.ip_addr == null)
            setAddressToLocalHost();
    }



    public IpAddress(InetAddress i, int p) {
        ip_addr=i; port=p;
        if(this.ip_addr == null)
            setAddressToLocalHost();
    }


    private void setAddressToLocalHost() {
        try {
            ip_addr=InetAddress.getLocalHost();  // get first NIC found (on multi-homed systems)
            // size=size();
        }
        catch(Exception e) {
            if(log.isWarnEnabled()) log.warn("exception: " + e);
        }
    }

    public IpAddress(int port) {
        this(port, true);
    }

    public IpAddress(int port, boolean set_default_host) {
        this.port=port;
        if(set_default_host)
            setAddressToLocalHost();
    }



    public final InetAddress  getIpAddress()               {return ip_addr;}
    public final int          getPort()                    {return port;}

    public final boolean      isMulticastAddress() {
        return ip_addr != null && ip_addr.isMulticastAddress();
    }

    /**
     * Returns the additional_data.
     * @return byte[]
     */
    public final byte[] getAdditionalData() {
        return additional_data;
    }

    /**
     * Sets the additional_data.
     * @param additional_data The additional_data to set
     */
    public final void setAdditionalData(byte[] additional_data) {
        this.additional_data = additional_data;
        size=size();
    }


    /**
     * Establishes an order between 2 addresses. Assumes other contains non-null IpAddress.
     * Excludes channel_name from comparison.
     * @return 0 for equality, value less than 0 if smaller, greater than 0 if greater.
     */
    public final int compare(IpAddress other) {
        return compareTo(other);
    }


    /**
     * implements the java.lang.Comparable interface
     * @see java.lang.Comparable
     * @param o - the Object to be compared
     * @return a negative integer, zero, or a positive integer as this object is less than,
     *         equal to, or greater than the specified object.
     * @exception java.lang.ClassCastException - if the specified object's type prevents it
     *            from being compared to this Object.
     */
    public final int compareTo(Object o) {
        int   h1, h2, rc; // added Nov 7 2005, makes sense with canonical addresses

        if(this == o) return 0;
        if ((o == null) || !(o instanceof IpAddress))
            throw new ClassCastException("comparison between different classes: the other object is " +
                    (o != null? o.getClass() : o));
        IpAddress other = (IpAddress) o;
        if(ip_addr == null)
            if (other.ip_addr == null) return port < other.port ? -1 : (port > other.port ? 1 : 0);
            else return -1;
      
        h1=ip_addr.hashCode();
        h2=other.ip_addr.hashCode();
        rc=h1 < h2? -1 : h1 > h2? 1 : 0;
        return rc != 0 ? rc : port < other.port ? -1 : (port > other.port ? 1 : 0);
    }



    public final boolean equals(Object obj) {
        if(this == obj) return true; // added Nov 7 2005, makes sense with canonical addresses
        if(obj == null) return false;
        return compareTo(obj) == 0 ? true : false;
    }




    public final int hashCode() {
        return ip_addr != null ? ip_addr.hashCode() + port : port;
    }




    public String toString() {
        StringBuffer sb=new StringBuffer();

        if(ip_addr == null)
            sb.append("<null>");
        else {
            if(ip_addr.isMulticastAddress())
                sb.append(ip_addr.getHostAddress());
            else {
                String host_name=null;
                if(resolve_dns)
                    host_name=ip_addr.getHostName();
                else
                    host_name=ip_addr.getHostAddress();
                appendShortName(host_name, sb);
            }
        }
        sb.append(":" + port);
        return sb.toString();
    }





    /**
     * Input: "daddy.nms.fnc.fujitsu.com", output: "daddy". Appends result to string buffer 'sb'.
     * @param hostname The hostname in long form. Guaranteed not to be null
     * @param sb The string buffer to which the result is to be appended
     */
    private void appendShortName(String hostname, StringBuffer sb) {
        if(hostname == null) return;
        int  index=hostname.indexOf('.');
        if(index > 0 && !Character.isDigit(hostname.charAt(0)))
            sb.append(hostname.substring(0, index));
        else
            sb.append(hostname);
    }


    public void writeExternal(ObjectOutput out) throws IOException {
        byte[] address = ip_addr.getAddress();   
        out.write(address);   
        out.writeInt(port);
        if(additional_data != null) {
            out.writeInt(additional_data.length);
            out.write(additional_data, 0, additional_data.length);
        }
        else
            out.writeInt(0);
    } 
    
    
    
    
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        int len=0;   
        //read the four bytes
        byte[] a = new byte[4];   
        //in theory readFully(byte[]) should be faster   
        //than read(byte[]) since latter reads   
        // 4 bytes one at a time   
        in.readFully(a);   
        //then read the port
        port = in.readInt();
        //look up an instance in the cache
        this.ip_addr=InetAddress.getByAddress(a);
        len=in.readInt();
        if(len > 0) {
            additional_data=new byte[len];
            in.readFully(additional_data, 0, additional_data.length);        
        }
    }

    public void writeTo(DataOutputStream out) throws IOException {
        byte[] address;

        if(ip_addr != null) {
            address=ip_addr.getAddress();
            out.writeShort(address.length); // 2 bytes
            out.write(address, 0, address.length);
        }
        else {
            out.writeShort(0);
        }
        out.writeInt(port);
        if(additional_data != null) {
            out.writeBoolean(true); // 1 byte
            out.writeInt(additional_data.length);
            out.write(additional_data, 0, additional_data.length);
        }
        else {
            out.writeBoolean(false);
        }
    }

    public void readFrom(DataInputStream in) throws IOException {
        int len=in.readShort();
        if(len > 0) {
            //read the four bytes
            byte[] a = new byte[len];
            //in theory readFully(byte[]) should be faster
            //than read(byte[]) since latter reads
            // 4 bytes one at a time
            in.readFully(a);
            //look up an instance in the cache
            this.ip_addr=InetAddress.getByAddress(a);
        }
        //then read the port
        port=in.readInt();

        if(in.readBoolean() == false)
            return;
        len=in.readInt();
        if(len > 0) {
            additional_data=new byte[len];
            in.readFully(additional_data, 0, additional_data.length);
        }
    }

    public int size() {
        if(size >= 0)
            return size;
        // length + 4 bytes for port + 1 for additional_data available
        int tmp_size=Global.SHORT_SIZE + Global.INT_SIZE + Global.BYTE_SIZE;
        if(ip_addr != null)
            tmp_size+=ip_addr.getAddress().length; // 4 bytes for IPv4
        if(additional_data != null)
            tmp_size+=additional_data.length+Global.INT_SIZE;
        size=tmp_size;
        return tmp_size;
    }

    public Object clone() throws CloneNotSupportedException {
        IpAddress ret=new IpAddress(ip_addr, port);
        if(additional_data != null) {
            ret.additional_data=new byte[additional_data.length];
            System.arraycopy(additional_data, 0, ret.additional_data, 0, additional_data.length);
        }
        return ret;
    }



}
