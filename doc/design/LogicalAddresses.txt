

Logical addresses
=================

Author:  Bela Ban
Version: $Id: LogicalAddresses.txt,v 1.12 2009/02/11 11:01:26 belaban Exp $
JIRA:    https://jira.jboss.org/jira/browse/JGRP-129

The address chosen by each node is essentially the IP address and port of the receiver socket. However, for the
following reasons, this is not good enough:

- Reincarnation: if we use fixed ports (bind_port is set), then a restarted (or shunned) node will have the same
  address. If other nodes in the cluster don't clear their states before the reincarnated node comes up again, we'll
  have issues (see JGRP-130 for details)

- NIC failover: a NIC goes down, we want to continue sending/receiving on a different NIC

- The sender sends on all available NICs (send_on_all_interfaces="true"). This means that -if we take the receiver's
datagram packet's address to be the identity of the sender - we get N different identities; 1 for each interface
the message is sent on

- Network Address Translation: the sender's address might get changed by the NAT

DESIGN:

- A logical address consists of a unique identifier (UUID) and a logical name. The name is passed to JGroups when a
 channel is created (new JChannel(String logical_name, String props)). If logical_name is null, JGroups picks a
 logical name (which is not guaranteed to be unique though). The logical name stays with the channel until the latter
 is destroyed

- A UUID is represented by org.jgroups.util.UUID, which is a subclass of Address and consists of the least and
  most significant bits variables copied from java.util.UUID. All other instance variables are omitted.
  - The isMulticastAddress() method uses 1 bit out of the 128 bits of UUID
    (Maybe we can remove this method and always represent multicast addresses as nulls, so UUIDs would only be used
     to represent non multicast addresses)

- All UUIDs have a reference to a static table which contains the mappings between logical names and UUIDs
  (classloader issues ?)

- The logical name is used in UUID.toString(), and the least and most significant bits are used for equals() and
  hashCode()

- A UUID is created on channel connect, deleted on channel disconnect and re-created on channel connect.
  Since it is re-created on every connect(), it will prevent reincarnation issues

Transport (TP)
--------------

TP maintains a cache of mappings between UUIDs and physical addresses. Whenever a message is sent, the physical address
of the receiver is looked up from the cache.

A UUID can have more than 1 physical address. We envisage providing a pluggable strategy which picks a physical
address given a UUID. For example, a plugin could load balance between physical addresses.

To exchange cache information, we'll use a simple (TP-internal) protocol similar to ARP. Whenever the cache is changed,
we set a 'dirty' flag. The next down message(s) will then attached the cache contents to the message in an additional
I-HAVE header. Receiving nodes will update their local caches upon reception.

When a physical address for a given UUID is not present, a sender discards (or queues, TBD) the message and broadcasts
a WHO-HAS message. Receivers then broadcast (or unicast) the UUID-physical address mapping.

The discovery phase needs to return logical *and* physical addresses: on reception of a discovery request, we return
our logical address (UUID) and the physical address(es) associated with it, plus the logical name. On reception
of a discovery response, the transport places the physical addresses returned into its cache (if not yet present).
See the scenarios below for details as to why this is needed.


UDP startup
-----------
- The joiner multicasts a discovery request with its UUID, logical name and physical address(es)
- The receivers' transports add this information into their caches
- Each receiver unicasts a discovery response, containing the coordinator's address, plus its own UUID, logical
  name and physical address(es)
- On reception of a discovery response, the transport adds this information to its cache if not yet there


TCPPING:TCP startup
-------------------
- The problem is that TCPPING has as initial_hosts the *physical* (not logical) addresses listed !
- The joiner sends a discovery request to all physical addresses listed in initial_hosts
- The dest_addr field of a discovery request message is the physical address
- The transport usually expects UUIDs as addresses and finds the right physical address in the cache
- However, in this case, the transport re-uses the physical address (dest_addr) in the message, bypasses the
  translation UUID --> physical address, and nulls dest_addr in Message
- The destination address is now *null*. This works because Discovery/PING/TCPPING don't check the messages's
  dest_addr field ! (Otherwise 'null' would be interpreted as a multicast destination !)
- On the receiver side, the destination is not used for discovery
- The response is sent back to the sender (Message.getSrc()), this is a UUID and will be translated back
  into a physical address


TCPGOSSIP:TCP startup
---------------------
- The joiner asks the GossipRouter for a list of nodes for a given cluster name
- The information returned contains a list of nodes, for each node:
  - The logical address (UUID)
  - The logical name
  - The physical address(es) associated with the UUID
- The joiner's transport adds this information to its cache
- Then each node of the initial membership is sent a discovery request
- The rest is the same as for UDP


TCPGOSSIP:TUNNEL startup
------------------------
- Same as for TCPGOSSIP:TCP, but here we don't really need the physical addresses, because we send every request
  to the GossipRouter anyway (via our TCP connection to it)
- The physical address will simply be ignored


ARP-like functionality
----------------------
- This is handled by Discovery
- We'll add WHO-HAS, I-HAVE and INVALIDATE message handling to Discovery
- Discovery and transport communicate via events
- When the transport wants to send a message whose destination UUID is not in its cache, it sends a (non-blocking)
  WHO-HAS up the stack which is handled by Discovery. Meanwhile the message is queued (bounded queue).
- Discovery sends a WHO-HAS(UUID) message (multicast if PING, sent to initial_hosts in TCPPING, or sent to the
  GossipRouter if TCPGOSSIP)
- On reception of  I-HAVE, Discovery sends the result down the stack via an I-HAVE event
- When the transport receives an I-HAVE event, it updates its local cache and then tries to send the queued messages
- A discovery request also ships the logical name and physical address(es)
- A discovery response also contains these items
- When a discovery request or response is received, the cache is updated if necessary
- When a channel is closed, we send an INVALIDATE(UUID) message around, which removes the UUID from UUID.cache and
  the transport's cache in all cluster nodes



Runtime scenarios
-----------------

Startup
-------
- The transport stores the logical name (generated if user didn't pass one to the JChannel() constructor)
- On connect:
  - The UUID is generated (local address) and associated with the logical name (in UUID.cache)
  - The local socket is created and associated with the UUID in the transport's cache
- On disconnect: the local_addr (UUID) is nulled and removed from the transport's cache and UUID.cache
- On close: an INVALIDATE(UUID) message is broadcast so every node can remove UUID from the transport's cache
  and from UUID.cache

Discovery
---------
- Discovery fetches the local_addr (UUID), logical name and physical address(es) from the transport via a
  GET-LOCAL-ADDR-INFO
- A discovery request containing this info is sent out (multicast, unicast via TCP or sent to GossipRouter)
- The receivers (Discovery protocols) fetch this info from the message and send it down to the transport, which
  adds it to its cache and to UUID.cache
- The receivers then fetch their own local information from the transport and send it along with the discovery
  response
- On reception of the discovery response, the requester extracts this info from the message and sends it
  down to its transport, which adds it to its own local cache

Sending of a message with no physical address available for UUID
----------------------------------------------------------------
- The transport queues the message
- The transport sends a WHO-HAS *event* up the stack
- The Discovery protocol sends out a WHO-HAS *message* (via multicast, TCP unicast, or to the GossipRouter)
- The receivers fetch their local information from the transport (exception: the GossipRouter has this information
  in its local loookup cache), and return it with a I-HAVE message
- On reception of the I-HAVE message, an I-HAVE event is sent down the stack to the transport
- The transport updates its local cache from the information
- The transport sends all queued messages if the UUID are now available



TODOs
-----
- Multicast messages should always be null, so Address.isMulticastAddress() should not be needed anymore
- GossipRouter: we need to register logical *and* physical addresses, plus the logical name
- Find all uses of IpAddress and change them to SocketAddress (if possible), or try to use Address rather than
  IpAddress
- [TBD] Change IpAddress into PhysicalAddress (?)
- UUID: generate a nice name from UUID if the logical name is not defined. Alternative: don't use the UUID to generate
  the logical name, but maybe the host name and a random short



